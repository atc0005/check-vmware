// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"

	"github.com/atc0005/go-nagios"
	"github.com/vmware/govmomi/units"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	zlog "github.com/rs/zerolog/log"
)

//go:generate go-winres make --product-version=git-tag --file-version=git-tag

func main() {

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Annotate all errors (if any) with remediation advice just before ending
	// plugin execution.
	defer vsphere.AnnotateError(plugin)

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{ResourcePoolsMemory: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateUNKNOWNLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return
	}

	// Enable library-level logging if debug or greater logging level is
	// enabled app-wide.
	handleLibraryLogging()

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	// Record thresholds for use as Nagios "Long Service Output" content. This
	// content is shown in the detailed web UI and in notifications generated
	// by Nagios.
	plugin.CriticalThreshold = fmt.Sprintf(
		"%d%% usage of %d GB memory",
		cfg.ResourcePoolsMemoryUseCritical,
		cfg.ResourcePoolsMemoryMaxAllowed,
	)

	plugin.WarningThreshold = fmt.Sprintf(
		"%d%% usage of %d GB memory",
		cfg.ResourcePoolsMemoryUseWarning,
		cfg.ResourcePoolsMemoryMaxAllowed,
	)

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	// Setup logger with details showing actual user-specified CLI flag
	// values.
	log := cfg.Log.With().
		Str("included_resource_pools", cfg.IncludedResourcePools.String()).
		Str("excluded_resource_pools", cfg.ExcludedResourcePools.String()).
		Int("max_memory_usage_allowed", cfg.ResourcePoolsMemoryMaxAllowed).
		Int("memory_usage_critical", cfg.ResourcePoolsMemoryUseCritical).
		Int("memory_usage_warning", cfg.ResourcePoolsMemoryUseWarning).
		Logger()

	log.Debug().Msgf(
		"Explicitly excluding %q default/root/parent Resource Pool from evaluation",
		vsphere.ParentResourcePool,
	)

	// Explicitly ignore the default `Resources` resource pool so that we only
	// use the Resource Pools specified by the sysadmin.
	if err := cfg.ExcludedResourcePools.Set(vsphere.ParentResourcePool); err != nil {
		log.Err(cfgErr).Msg("Error excluding default Resource Pool from evaluation")
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error excluding default Resources Pool from evaluation",
			nagios.StateCRITICALLabel,
		)
		plugin.AddError(err)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Redefine logger, now with explicit exclusion added for parent resource
	// pool.
	log = cfg.Log.With().
		Str("included_resource_pools", cfg.IncludedResourcePools.String()).
		Str("excluded_resource_pools", cfg.ExcludedResourcePools.String()).
		Int("max_memory_usage_allowed", cfg.ResourcePoolsMemoryMaxAllowed).
		Int("memory_usage_critical", cfg.ResourcePoolsMemoryUseCritical).
		Int("memory_usage_warning", cfg.ResourcePoolsMemoryUseWarning).
		Logger()

	log.Debug().Msgf(
		"Successfully excluded %q Resource Pool from evaluation",
		vsphere.ParentResourcePool,
	)

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		plugin.AddError(loginErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	log.Debug().Msg("Filtering vms")
	vmsFilterOptions := vsphere.VMsFilterOptions{
		ResourcePoolsIncluded: cfg.IncludedResourcePools,
		ResourcePoolsExcluded: cfg.ExcludedResourcePools,

		// No Exclusions; evaluate all VMs for non-excluded or explicitly
		// included resource pools.
		FoldersIncluded:             []string{},
		FoldersExcluded:             []string{},
		VirtualMachineNamesExcluded: []string{},

		// Powered off VMs do not consume memory, so no need to evaluate them.
		IncludePoweredOff: false,
	}
	vmsFilterResults, vmsFilterErr := vsphere.FilterVMs(
		ctx,
		c.Client,
		vmsFilterOptions,
	)
	if vmsFilterErr != nil {
		log.Error().Err(vmsFilterErr).Msg(
			"error filtering VMs",
		)

		plugin.AddError(vmsFilterErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error filtering VMs",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Finished filtering vms")

	log.Debug().Msg("Retrieving stats for resource pools")
	aggregateRPStats, rpStatsErr := vsphere.ResourcePoolStats(ctx, c.Client, vmsFilterResults.RPsAfterFiltering())
	if rpStatsErr != nil {
		log.Error().Err(rpStatsErr).Msg(
			"error retrieving stats for resource pools",
		)

		plugin.AddError(rpStatsErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving stats for resource pools from %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully retrieved stats for resource pools")

	log.Debug().Msg("Retrieving hosts memory capacity")
	clusterMemoryInBytes, getMemErr := vsphere.GetHostSystemsTotalMemory(ctx, c.Client, false)
	if getMemErr != nil {
		log.Error().Err(getMemErr).Msg(
			"error retrieving hosts memory capacity",
		)

		plugin.AddError(getMemErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving memory capacity of hosts from %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully retrieved hosts memory capacity")

	memoryPercentageUsedOfClusterCapacity := vsphere.MemoryUsedPercentage(
		aggregateRPStats.MemoryUsageInBytes,
		clusterMemoryInBytes,
	)

	log.Debug().
		Int64("cluster_memory_bytes", clusterMemoryInBytes).
		Str("cluster_memory_hr", units.ByteSize(clusterMemoryInBytes).String()).
		Float64("percent_memory_used_from_cluster_raw", memoryPercentageUsedOfClusterCapacity).
		Str("percent_memory_used_from_cluster_hr", fmt.Sprintf("%0.2f", memoryPercentageUsedOfClusterCapacity)).
		Msg("")

	log.Debug().
		Int64("aggregate_memory_usage_bytes", aggregateRPStats.MemoryUsageInBytes).
		Str("aggregate_memory_usage_hr", units.ByteSize(aggregateRPStats.MemoryUsageInBytes).String()).
		Msg("Finished evaluating Resource Pool memory usage")

	memoryUsageMaxInBytes := (int64(cfg.ResourcePoolsMemoryMaxAllowed) * units.GB)
	memoryPercentageUsedOfAllowed := vsphere.MemoryUsedPercentage(aggregateRPStats.MemoryUsageInBytes, memoryUsageMaxInBytes)
	var memoryRemainingInBytes int64

	switch {
	case aggregateRPStats.MemoryUsageInBytes > memoryUsageMaxInBytes:
		memoryRemainingInBytes = 0
	default:
		memoryRemainingInBytes = memoryUsageMaxInBytes - aggregateRPStats.MemoryUsageInBytes
	}

	log.Debug().
		Str("memory_usage", fmt.Sprintf("%.2f%%", memoryPercentageUsedOfAllowed)).
		Int64("memory_remaining_bytes", memoryRemainingInBytes).
		Str("memory_remaining_hr", units.ByteSize(memoryRemainingInBytes).String()).
		Int64("max_allowed_memory_bytes", memoryUsageMaxInBytes).
		Str("max_allowed_memory_bytes_hr", units.ByteSize(memoryUsageMaxInBytes).String()).
		Msg("memory usage")

	log.Debug().Msg("Compiling Performance Data details")

	pd := append(
		vsphere.VMFilterResultsPerfData(vmsFilterResults),
		[]nagios.PerformanceData{
			// The `time` (runtime) metric is appended at plugin exit, so do not
			// duplicate it here.
			{
				Label:             "memory_usage",
				Value:             fmt.Sprintf("%.2f", memoryPercentageUsedOfAllowed),
				UnitOfMeasurement: "%",
				Warn:              fmt.Sprintf("%d", cfg.ResourcePoolsMemoryUseWarning),
				Crit:              fmt.Sprintf("%d", cfg.ResourcePoolsMemoryUseCritical),
			},
			{
				Label:             "memory_used",
				Value:             fmt.Sprintf("%d", aggregateRPStats.MemoryUsageInBytes),
				UnitOfMeasurement: "B",
			},
			{
				Label:             "memory_remaining",
				Value:             fmt.Sprintf("%d", memoryRemainingInBytes),
				UnitOfMeasurement: "B",
			},
			{
				Label:             "memory_ballooned",
				Value:             fmt.Sprintf("%d", aggregateRPStats.BalloonedMemoryInBytes),
				UnitOfMeasurement: "B",
			},
			{
				Label:             "memory_swapped",
				Value:             fmt.Sprintf("%d", aggregateRPStats.SwappedMemoryInBytes),
				UnitOfMeasurement: "B",
			},
		}...,
	)

	if err := plugin.AddPerfData(false, pd...); err != nil {
		log.Error().
			Err(err).
			Msg("failed to add performance data")

		// Surface the error in plugin output.
		plugin.AddError(err)

		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Failed to process performance data metrics",
			nagios.StateUNKNOWNLabel,
		)

		return
	}

	// Update logger with new performance data related fields
	log = log.With().
		Int("resource_pools_evaluated", vmsFilterResults.NumRPsAfterFiltering()).
		Int("vms_total", vmsFilterResults.NumVMsAll()).
		Int("vms_after_filtering", vmsFilterResults.NumVMsAfterFiltering()).
		Str("memory_usage", fmt.Sprintf("%.2f%%", memoryPercentageUsedOfAllowed)).
		Int64("memory_used", aggregateRPStats.MemoryUsageInBytes).
		Int64("memory_remaining_bytes", memoryRemainingInBytes).
		Str("memory_remaining_hr", units.ByteSize(memoryRemainingInBytes).String()).
		Int64("memory_ballooned_bytes", aggregateRPStats.BalloonedMemoryInBytes).
		Str("memory_ballooned_hr", aggregateRPStats.BalloonedMemoryHR()).
		Int64("memory_swapped_bytes", aggregateRPStats.SwappedMemoryInBytes).
		Str("memory_swapped_hr", aggregateRPStats.SwappedMemoryHR()).
		Int64("max_allowed_memory_bytes", memoryUsageMaxInBytes).
		Str("max_allowed_memory_bytes_hr", units.ByteSize(memoryUsageMaxInBytes).String()).
		Logger()

	switch {
	case memoryPercentageUsedOfAllowed > float64(cfg.ResourcePoolsMemoryUseCritical):

		log.Error().Msg("memory usage critical")

		plugin.AddError(vsphere.ErrResourcePoolMemoryUsageThresholdCrossed)

		plugin.ServiceOutput = vsphere.RPMemoryUsageOneLineCheckSummary(
			nagios.StateCRITICALLabel,
			vmsFilterResults,
			aggregateRPStats.MemoryUsageInBytes,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.LongServiceOutput = vsphere.ResourcePoolsMemoryReport(
			c.Client,
			vmsFilterOptions,
			vmsFilterResults,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	case memoryPercentageUsedOfAllowed > float64(cfg.ResourcePoolsMemoryUseWarning):

		log.Error().Msg("memory usage warning")

		plugin.AddError(vsphere.ErrResourcePoolMemoryUsageThresholdCrossed)

		plugin.ServiceOutput = vsphere.RPMemoryUsageOneLineCheckSummary(
			nagios.StateWARNINGLabel,
			vmsFilterResults,
			aggregateRPStats.MemoryUsageInBytes,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.LongServiceOutput = vsphere.ResourcePoolsMemoryReport(
			c.Client,
			vmsFilterOptions,
			vmsFilterResults,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.ExitStatusCode = nagios.StateWARNINGExitCode

		return

	default:

		log.Debug().Msg("memory usage ok")

		plugin.ServiceOutput = vsphere.RPMemoryUsageOneLineCheckSummary(
			nagios.StateOKLabel,
			vmsFilterResults,
			aggregateRPStats.MemoryUsageInBytes,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.LongServiceOutput = vsphere.ResourcePoolsMemoryReport(
			c.Client,
			vmsFilterOptions,
			vmsFilterResults,
			memoryUsageMaxInBytes,
			clusterMemoryInBytes,
		)

		plugin.ExitStatusCode = nagios.StateOKExitCode

		return

	}

}
