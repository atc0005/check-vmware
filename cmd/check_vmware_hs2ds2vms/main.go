// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/atc0005/go-nagios"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	zlog "github.com/rs/zerolog/log"
)

//go:generate go-winres make --product-version=git-tag --file-version=git-tag

func main() {

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Annotate all errors (if any) with remediation advice just before ending
	// plugin execution.
	defer vsphere.AnnotateError(plugin)

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{Host2Datastores2VMs: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateUNKNOWNLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return
	}

	// Enable library-level logging if debug or greater logging level is
	// enabled app-wide.
	handleLibraryLogging()

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	// Record thresholds for use as Nagios "Long Service Output" content. This
	// content is shown in the detailed web UI and in notifications generated
	// by Nagios.
	plugin.CriticalThreshold = "Any errors encountered or Hosts/Datastores/VMs mismatches."
	plugin.WarningThreshold = "Not used by this plugin."

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	log := cfg.Log.With().
		Str("included_resource_pools", cfg.IncludedResourcePools.String()).
		Str("excluded_resource_pools", cfg.ExcludedResourcePools.String()).
		Str("ignored_vms", cfg.IgnoredVMs.String()).
		Bool("eval_powered_off", cfg.PoweredOff).
		Bool("ignore_missing_ca_on_objects", cfg.IgnoreMissingCustomAttribute).
		Str("datastore_ca_name", cfg.DatastoreCAName()).
		Str("datastore_ca_prefix_separator", cfg.DatastoreCASep()).
		Str("host_ca_name", cfg.HostCAName()).
		Str("host_ca_prefix_separator", cfg.HostCASep()).
		Logger()

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		plugin.AddError(loginErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	log.Debug().Msg("Performing initial filtering of vms")
	vmsFilterOptions := vsphere.VMsFilterOptions{
		ResourcePoolsIncluded:       cfg.IncludedResourcePools,
		ResourcePoolsExcluded:       cfg.ExcludedResourcePools,
		FoldersIncluded:             cfg.IncludedFolders,
		FoldersExcluded:             cfg.ExcludedFolders,
		VirtualMachineNamesExcluded: cfg.IgnoredVMs,
		IncludePoweredOff:           cfg.PoweredOff,
	}
	vmsFilterResults, vmsFilterErr := vsphere.FilterVMs(
		ctx,
		c.Client,
		vmsFilterOptions,
	)
	if vmsFilterErr != nil {
		log.Error().Err(vmsFilterErr).Msg(
			"error filtering VMs",
		)

		plugin.AddError(vmsFilterErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error filtering VMs",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Finished initial filtering of vms")

	// here we diverge from other plugins

	allDS, dssErr := vsphere.GetDatastores(ctx, c.Client, true)
	if dssErr != nil {
		log.Error().Err(dssErr).Msg(
			"error retrieving list of datastores",
		)

		plugin.AddError(dssErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of datastores",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	dsCustomAttributeName := cfg.DatastoreCAName()
	dsWithCAs, dsLookupErr := vsphere.GetDatastoresWithCA(
		allDS,
		cfg.IgnoredDatastores,
		dsCustomAttributeName,
		cfg.IgnoreMissingCustomAttribute,
	)
	if dsLookupErr != nil {

		log.Error().Err(dsLookupErr).
			Str("custom_attribute_name", dsCustomAttributeName).
			Msg("error retrieving datastores with specified Custom Attribute")

		plugin.AddError(dsLookupErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving datastores with Custom Attribute %q",
			nagios.StateCRITICALLabel,
			dsCustomAttributeName,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	}

	// Debug logging for troubleshooting purposes.
	for _, ds := range dsWithCAs {
		log.Debug().
			Str("datastore", ds.Name).
			Str("custom_attribute_name", ds.CustomAttribute.Name).
			Str("custom_attribute_value", ds.CustomAttribute.Value).
			Msg("datastores DatastoreWithCA list entry")
	}

	allHosts, hsErr := vsphere.GetHostSystems(ctx, c.Client, true)
	if hsErr != nil {
		log.Error().Err(hsErr).Msg(
			"error retrieving list of hosts",
		)

		plugin.AddError(hsErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of hosts",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	hostCustomAttributeName := cfg.HostCAName()
	hostsWithCAs, hostsLookupErr := vsphere.GetHostsWithCA(
		allHosts,
		hostCustomAttributeName,
		cfg.IgnoreMissingCustomAttribute,
	)
	if hostsLookupErr != nil {

		log.Error().Err(hostsLookupErr).
			Str("custom_attribute_name", hostCustomAttributeName).
			Msg("error retrieving hosts with specified Custom Attribute")

		plugin.AddError(hostsLookupErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving hosts with Custom Attribute %q",
			nagios.StateCRITICALLabel,
			hostCustomAttributeName,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	}

	// Debug logging for troubleshooting purposes.
	for _, host := range hostsWithCAs {
		log.Debug().
			Str("host", host.Name).
			Str("hostMOID", host.Self.Value).
			Str("custom_attribute_name", host.CustomAttribute.Name).
			Str("custom_attribute_value", host.CustomAttribute.Value).
			Msg("host, hostMOID and custom attributes used to build index")
	}

	// Create host-to-datastore index for *all* hosts and datastores, even
	// where a host has no matching datastores (via specified literal or
	// prefix custom attribute values).
	h2dIdx, h2dIdxErr := vsphere.NewHostToDatastoreIndex(
		hostsWithCAs,
		dsWithCAs,
		cfg.UsingCAPrefixes(),
		cfg.HostCASep(),
		cfg.DatastoreCASep(),
	)

	// make sure we have at least one pairing, otherwise bail
	if h2dIdxErr != nil {

		var errMsg string
		switch {
		case errors.Is(h2dIdxErr, vsphere.ErrHostDatastorePairingFailed):
			errMsg = "no matching datastores and hosts found using provided Custom Attribute"

		default:
			errMsg = "unknown error encountered while evaluating datastores and hosts for Custom Attribute"
		}

		log.Error().Err(h2dIdxErr).Msg(errMsg)

		plugin.ServiceOutput = fmt.Sprintf(
			"%s: %s [host: %q, datastore: %q]",
			nagios.StateCRITICALLabel,
			errMsg,
			hostCustomAttributeName,
			dsCustomAttributeName,
		)

		plugin.AddError(h2dIdxErr)

		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	}

	// Debug logging for troubleshooting purposes.
	for hostID, pairing := range h2dIdx {
		// Reassign the iteration variable inside the loop to prevent implicit
		// memory aliasing.
		// https://stackoverflow.com/questions/62446118/implicit-memory-aliasing-in-for-loop
		hostID, pairing := hostID, pairing

		dsNamesForHost := func(pairings vsphere.HostDatastoresPairing) string {
			names := make([]string, len(pairings.Datastores))
			for i := range pairings.Datastores {
				names[i] = pairings.Datastores[i].Name
			}
			return strings.Join(names, ", ")
		}(pairing)

		log.Debug().
			Str("host", h2dIdx[hostID].Host.Name).
			Str("hostMOID", hostID).
			Str("datastores", dsNamesForHost).
			Msg("host/datastores pairing from index")
	}

	// now process VMs
	vmDatastoresPairingIssues, lookupErr := vsphere.GetVMDatastorePairingIssues(
		vmsFilterResults.VMsAfterFiltering(),
		h2dIdx,
		allDS,
		cfg.IgnoredDatastores,
	)
	if lookupErr != nil {
		errMsg := "Error retrieving VMs/Datastores pairing issues"

		log.Error().Err(lookupErr).Msg(errMsg)

		plugin.AddError(lookupErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: %s",
			nagios.StateCRITICALLabel,
			errMsg,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	numMismatches := len(vmDatastoresPairingIssues)

	log.Debug().Msg("Compiling Performance Data details")

	pd := append(
		vsphere.VMFilterResultsPerfData(vmsFilterResults),
		[]nagios.PerformanceData{
			// The `time` (runtime) metric is appended at plugin exit, so do not
			// duplicate it here.
			{
				Label: "pairing_issues",
				Value: fmt.Sprintf("%d", numMismatches),
			},
			{
				Label: "datastores",
				Value: fmt.Sprintf("%d", len(allDS)),
			},
			{
				Label: "hosts",
				Value: fmt.Sprintf("%d", len(allHosts)),
			},
		}...,
	)

	if err := plugin.AddPerfData(false, pd...); err != nil {
		log.Error().
			Err(err).
			Msg("failed to add performance data")

		// Surface the error in plugin output.
		plugin.AddError(err)

		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Failed to process performance data metrics",
			nagios.StateUNKNOWNLabel,
		)

		return
	}

	// Update logger with new performance data related fields
	log = log.With().
		Int("resource_pools_evaluated", vmsFilterResults.NumRPsAfterFiltering()).
		Int("vms_total", vmsFilterResults.NumVMsAll()).
		Int("vms_after_filtering", vmsFilterResults.NumVMsAfterFiltering()).
		Int("vms_excluded_by_name", vmsFilterResults.NumVMsExcludedByName()).
		Int("vms_excluded_by_power_state", vmsFilterResults.NumVMsExcludedByPowerState()).
		Int("pairing_issues", numMismatches).
		Int("datastores", len(allDS)).
		Int("hosts", len(allHosts)).
		Int("mismatched_vms_count", numMismatches).
		Logger()

	switch {
	// expected failure scenario; set LongServiceOutput using report func
	case numMismatches > 0:

		var vmNames []string
		for vmName := range vmDatastoresPairingIssues {
			vmNames = append(vmNames, vmName)
		}
		sort.Strings(vmNames)

		log.Error().
			Str("mismatched_vms_list", strings.Join(vmNames, ", ")).
			Msg("VM/Host/Datastore validation failed")

		plugin.AddError(vsphere.ErrVMDatastoreNotInVMHostPairedList)

		plugin.ServiceOutput = vsphere.H2D2VMsOneLineCheckSummary(
			nagios.StateCRITICALLabel,
			vmsFilterResults,
			vmDatastoresPairingIssues,
		)

		plugin.LongServiceOutput = vsphere.H2D2VMsReport(
			c.Client,
			h2dIdx,
			vmsFilterOptions,
			vmsFilterResults,
			vmDatastoresPairingIssues,
			cfg.IgnoreMissingCustomAttribute,
			cfg.IgnoredDatastores,
			cfg.DatastoreCASep(),
			cfg.HostCASep(),
			cfg.DatastoreCAName(),
			cfg.HostCAName(),
		)

		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	default:
		// success if we made it here

		log.Debug().Msg("No mismatched Host/Datastore/VM pairings detected")

		plugin.ServiceOutput = vsphere.H2D2VMsOneLineCheckSummary(
			nagios.StateOKLabel,
			vmsFilterResults,
			vmDatastoresPairingIssues,
		)

		plugin.LongServiceOutput = vsphere.H2D2VMsReport(
			c.Client,
			h2dIdx,
			vmsFilterOptions,
			vmsFilterResults,
			vmDatastoresPairingIssues,
			cfg.IgnoreMissingCustomAttribute,
			cfg.IgnoredDatastores,
			cfg.DatastoreCASep(),
			cfg.HostCASep(),
			cfg.DatastoreCAName(),
			cfg.HostCAName(),
		)

		plugin.ExitStatusCode = nagios.StateOKExitCode

	}

}
