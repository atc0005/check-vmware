// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/atc0005/go-nagios"
	"github.com/vmware/govmomi/vim25/mo"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	zlog "github.com/rs/zerolog/log"
)

//go:generate go-winres make --product-version=git-tag --file-version=git-tag

func main() {

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Annotate all errors (if any) with remediation advice just before ending
	// plugin execution.
	defer vsphere.AnnotateError(plugin)

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{VirtualHardwareVersion: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateUNKNOWNLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return
	}

	// Enable library-level logging if debug or greater logging level is
	// enabled app-wide.
	handleLibraryLogging()

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	log := cfg.Log.With().
		Str("included_resource_pools", cfg.IncludedResourcePools.String()).
		Str("excluded_resource_pools", cfg.ExcludedResourcePools.String()).
		Str("ignored_vms", cfg.IgnoredVMs.String()).
		Bool("eval_powered_off", cfg.PoweredOff).
		Logger()

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		plugin.AddError(loginErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	// At this point we're logged in, ready to retrieve a list of VMs. If
	// specified, we should limit VMs based on include/exclude lists. First,
	// we'll make sure that all specified resource pools actually exist in the
	// vSphere environment.

	log.Debug().Msg("Validating resource pools")
	validateErr := vsphere.ValidateRPs(ctx, c.Client, cfg.IncludedResourcePools, cfg.ExcludedResourcePools)
	if validateErr != nil {
		log.Error().Err(validateErr).Msg("error validating include/exclude lists")

		plugin.AddError(validateErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error validating include/exclude lists",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Msg("Retrieving eligible resource pools")
	resourcePools, getRPsErr := vsphere.GetEligibleRPs(
		ctx,
		c.Client,
		cfg.IncludedResourcePools,
		cfg.ExcludedResourcePools,
		true,
	)
	if getRPsErr != nil {
		log.Error().Err(getRPsErr).Msg(
			"error retrieving list of resource pools",
		)

		plugin.AddError(getRPsErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of resource pools from %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	rpNames := make([]string, 0, len(resourcePools))
	for _, rp := range resourcePools {
		rpNames = append(rpNames, rp.Name)
	}

	log.Debug().
		Str("resource_pools", strings.Join(rpNames, ", ")).
		Msg("")

	log.Debug().Msg("Retrieving vms from eligible resource pools")
	rpEntityVals := make([]mo.ManagedEntity, 0, len(resourcePools))
	for i := range resourcePools {
		rpEntityVals = append(rpEntityVals, resourcePools[i].ManagedEntity)
	}
	vms, getVMsErr := vsphere.GetVMsFromContainer(ctx, c.Client, true, rpEntityVals...)
	if getVMsErr != nil {
		log.Error().Err(getVMsErr).Msg(
			"error retrieving list of VMs from resource pools list",
		)

		plugin.AddError(getVMsErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of VMs from resource pools list",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().
		Str("vms_evaluated", strings.Join(vsphere.VMNames(vms), ", ")).
		Msg("Evaluated Virtual Machines")

	log.Debug().Msg("Drop any VMs we've been asked to exclude from checks")
	filteredVMs, numVMsExcludedByName := vsphere.ExcludeVMsByName(vms, cfg.IgnoredVMs)

	log.Debug().
		Str("vms_filtered_by_name", strings.Join(vsphere.VMNames(filteredVMs), ", ")).
		Int("vms_excluded_by_name", numVMsExcludedByName).
		Msg("VMs after name filtering")

	log.Debug().Msg("Filter VMs to specified power state")
	filteredVMs, numVMsExcludedByPowerState := vsphere.FilterVMsByPowerState(filteredVMs, cfg.PoweredOff)

	log.Debug().
		Str("vms_filtered_by_power_state", strings.Join(vsphere.VMNames(filteredVMs), ", ")).
		Int("vms_excluded_by_power_state", numVMsExcludedByPowerState).
		Msg("VMs after power state filtering")

	// here we diverge from other plugins

	hardwareVersionsIdx, hwIdxErr := vsphere.NewHardwareVersionsIndex(filteredVMs)
	if hwIdxErr != nil {
		log.Error().Err(hwIdxErr).Msg("error creating virtual hardware index")

		plugin.AddError(hwIdxErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error creating index of virtual hardware versions",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	defaultHardwareVersion, getDefVerErr := vsphere.DefaultHardwareVersion(
		ctx,
		c.Client,
		cfg.HostSystemName,
		cfg.ClusterName,
		cfg.DatacenterName,
		hardwareVersionsIdx,
	)
	if getDefVerErr != nil {
		log.Error().Err(getDefVerErr).Msg(
			"error retrieving default hardware version",
		)

		plugin.AddError(getDefVerErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving default hardware version",
			nagios.StateCRITICALLabel,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().
		Int("default_hardware_version", defaultHardwareVersion.VersionNumber()).
		Int("vms_with_default_hardware_version", defaultHardwareVersion.Count()).
		Msg("")

	log.Debug().Msg("Compiling Performance Data details")

	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "vms",
			Value: fmt.Sprintf("%d", len(vms)),
		},
		{
			Label: "vms_excluded_by_name",
			Value: fmt.Sprintf("%d", numVMsExcludedByName),
		},
		{
			Label: "vms_excluded_by_power_state",
			Value: fmt.Sprintf("%d", numVMsExcludedByPowerState),
		},
		{
			Label: "hardware_versions_unique",
			Value: fmt.Sprintf("%d", hardwareVersionsIdx.Count()),
		},
		{
			Label: "hardware_versions_newest",
			Value: fmt.Sprintf("%d", hardwareVersionsIdx.Newest().Count()),
		},
		{
			Label: "hardware_versions_default",
			Value: fmt.Sprintf("%d", defaultHardwareVersion.Count()),
		},
		{
			Label: "hardware_versions_oldest",
			Value: fmt.Sprintf("%d", hardwareVersionsIdx.Oldest().Count()),
		},
		{
			Label: "resource_pools_excluded",
			Value: fmt.Sprintf("%d", len(cfg.ExcludedResourcePools)),
		},
		{
			Label: "resource_pools_included",
			Value: fmt.Sprintf("%d", len(cfg.IncludedResourcePools)),
		},
		{
			Label: "resource_pools_evaluated",
			Value: fmt.Sprintf("%d", len(resourcePools)),
		},
	}

	if err := plugin.AddPerfData(false, pd...); err != nil {
		log.Error().
			Err(err).
			Msg("failed to add performance data")

		// Surface the error in plugin output.
		plugin.AddError(err)

		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Failed to process performance data metrics",
			nagios.StateUNKNOWNLabel,
		)

		return
	}

	// Update logger with new performance data related fields
	log = log.With().
		Int("vms_total", len(vms)).
		Int("vms_filtered", len(filteredVMs)).
		Int("vms_excluded_by_name", numVMsExcludedByName).
		Int("vms_excluded_by_power_state", numVMsExcludedByPowerState).
		Int("hardware_versions_unique", hardwareVersionsIdx.Count()).
		Int("hardware_versions_newest", hardwareVersionsIdx.Newest().Count()).
		Int("hardware_versions_oldest", hardwareVersionsIdx.Oldest().Count()).
		Int("default_hardware_version", defaultHardwareVersion.VersionNumber()).
		Str("hardware_newest", hardwareVersionsIdx.Newest().String()).
		Str("hardware_oldest", hardwareVersionsIdx.Oldest().String()).
		Str("outdated_hardware_list", strings.Join(
			hardwareVersionsIdx.Outdated().VersionNames(), ", ")).
		Int("resource_pools_evaluated", len(resourcePools)).
		Logger()

	if cfg.VirtualHardwareApplyHomogeneousVersionCheck() {

		// Record thresholds for use as Nagios "Long Service Output" content. This
		// content is shown in the detailed web UI and in notifications generated
		// by Nagios.
		plugin.CriticalThreshold = config.ThresholdNotUsed
		plugin.WarningThreshold = "Non-homogenous hardware versions."

		switch {

		// There are at least two hardware versions present instead of a
		// uniform version across all VirtualMachines.
		case hardwareVersionsIdx.Count() > 1:

			log.Error().Msg("Virtual Hardware versions inconsistency detected")

			plugin.AddError(vsphere.ErrVirtualHardwareOutdatedVersionsFound)

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateWARNINGLabel,
				hardwareVersionsIdx.Newest().VersionNumber(),
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				hardwareVersionsIdx.Newest().VersionNumber(),
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateWARNINGExitCode

			return

		default:

			// same hardware version

			log.Debug().Msg("Homogenous hardware versions found")

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateOKLabel,
				hardwareVersionsIdx.Newest().VersionNumber(),
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				hardwareVersionsIdx.Newest().VersionNumber(),
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateOKExitCode

			return

		}

	}

	if cfg.VirtualHardwareApplyMinVersionCheck() {

		// Record thresholds for use as Nagios "Long Service Output" content. This
		// content is shown in the detailed web UI and in notifications generated
		// by Nagios.
		plugin.CriticalThreshold = fmt.Sprintf(
			"Hardware versions older than the minimum (%d) present.",
			cfg.VirtualHardwareMinimumVersion,
		)
		plugin.WarningThreshold = config.ThresholdNotUsed

		hardwareVersions := hardwareVersionsIdx.Versions()

		switch {
		case !hardwareVersions.MeetsMinVersion(cfg.VirtualHardwareMinimumVersion):

			log.Error().
				Msg("Virtual Hardware versions older than the specified minimum version detected")

			plugin.AddError(vsphere.ErrVirtualHardwareOutdatedVersionsFound)

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateCRITICALLabel,
				cfg.VirtualHardwareMinimumVersion,
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				cfg.VirtualHardwareMinimumVersion,
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateCRITICALExitCode

			return

		default:

			log.Debug().Msg("Minimum hardware version met")

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateOKLabel,
				cfg.VirtualHardwareMinimumVersion,
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				cfg.VirtualHardwareMinimumVersion,
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateOKExitCode

			return
		}

	}

	if cfg.VirtualHardwareApplyDefaultIsMinVersionCheck() {

		// Record thresholds for use as Nagios "Long Service Output" content. This
		// content is shown in the detailed web UI and in notifications generated
		// by Nagios.
		plugin.CriticalThreshold = config.ThresholdNotUsed

		plugin.WarningThreshold = fmt.Sprintf(
			"Hardware versions older than the default host or cluster (%d) present.",
			defaultHardwareVersion.VersionNumber(),
		)

		hardwareVersions := hardwareVersionsIdx.Versions()

		switch {
		case !hardwareVersions.MeetsMinVersion(defaultHardwareVersion.VersionNumber()):

			log.Error().
				Msg("Virtual Hardware versions older than the host or cluster default version detected")

			plugin.AddError(vsphere.ErrVirtualHardwareOutdatedVersionsFound)

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateWARNINGLabel,
				defaultHardwareVersion.VersionNumber(),
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				defaultHardwareVersion.VersionNumber(),
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateWARNINGExitCode

			return

		default:

			log.Debug().Msg("Default hardware version met")

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateOKLabel,
				defaultHardwareVersion.VersionNumber(),
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				defaultHardwareVersion.VersionNumber(),
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateOKExitCode

			return
		}

	}

	if cfg.VirtualHardwareApplyOutdatedByVersionCheck() {

		// Record thresholds for use as Nagios "Long Service Output" content. This
		// content is shown in the detailed web UI and in notifications generated
		// by Nagios.
		plugin.CriticalThreshold = fmt.Sprintf(
			"Hardware versions outdated by more than %d versions present.",
			cfg.VirtualHardwareOutdatedByCritical,
		)
		plugin.WarningThreshold = fmt.Sprintf(
			"Hardware versions outdated by more than %d versions present.",
			cfg.VirtualHardwareOutdatedByWarning,
		)

		hardwareVersions := hardwareVersionsIdx.Versions()
		latestHWVerNum := hardwareVersionsIdx.Newest().VersionNumber()
		criticalThresholdVerNum := latestHWVerNum - cfg.VirtualHardwareOutdatedByCritical
		warningThresholdVerNum := latestHWVerNum - cfg.VirtualHardwareOutdatedByWarning

		switch {
		case !hardwareVersions.MeetsMinVersion(criticalThresholdVerNum):

			log.Error().
				Msg("Virtual Hardware versions older than the specified minimum version detected")

			plugin.AddError(vsphere.ErrVirtualHardwareOutdatedVersionsFound)

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateCRITICALLabel,
				criticalThresholdVerNum,
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				criticalThresholdVerNum,
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateCRITICALExitCode

			return

		case !hardwareVersions.MeetsMinVersion(warningThresholdVerNum):

			log.Error().
				Msg("Virtual Hardware versions older than the specified minimum version detected")

			plugin.AddError(vsphere.ErrVirtualHardwareOutdatedVersionsFound)

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateWARNINGLabel,
				warningThresholdVerNum,
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				warningThresholdVerNum,
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateWARNINGExitCode

			return

		default:

			log.Debug().
				Msg("Virtual Hardware versions meet the specified minimum version")

			plugin.ServiceOutput = vsphere.VirtualHardwareOneLineCheckSummary(
				nagios.StateOKLabel,
				warningThresholdVerNum,
				filteredVMs,
				resourcePools,
			)

			plugin.LongServiceOutput = vsphere.VirtualHardwareReport(
				c.Client,
				hardwareVersionsIdx,
				warningThresholdVerNum,
				defaultHardwareVersion,
				vms,
				filteredVMs,
				cfg.IgnoredVMs,
				cfg.PoweredOff,
				cfg.IncludedResourcePools,
				cfg.ExcludedResourcePools,
				resourcePools,
			)

			plugin.ExitStatusCode = nagios.StateOKExitCode

			return
		}

	}

}
