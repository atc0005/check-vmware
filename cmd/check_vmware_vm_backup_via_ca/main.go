// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/atc0005/go-nagios"
	"github.com/vmware/govmomi/vim25/mo"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	zlog "github.com/rs/zerolog/log"
)

func main() {

	// Start the timer. We'll use this to emit the plugin runtime as a
	// performance data metric.
	pluginStart := time.Now()

	// Set initial "state" as valid, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Collect last minute details just before ending plugin execution.
	defer func(exitState *nagios.ExitState, start time.Time) {

		// Record plugin runtime, emit this metric regardless of exit
		// point/cause.
		runtimeMetric := nagios.PerformanceData{
			Label: "time",
			Value: fmt.Sprintf("%dms", time.Since(start).Milliseconds()),
		}
		if err := exitState.AddPerfData(false, runtimeMetric); err != nil {
			zlog.Error().
				Err(err).
				Msg("failed to add time (runtime) performance data metric")
		}

		// Annotate errors (if applicable) with additional context to aid in
		// troubleshooting.
		nagiosExitState.Errors = vsphere.AnnotateError(nagiosExitState.Errors...)
	}(&nagiosExitState, pluginStart)

	// Disable library debug logging output by default
	// vsphere.EnableLogging()
	vsphere.DisableLogging()

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{VirtualMachineLastBackupViaCA: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.AddError(cfgErr)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Enable library-level logging if debug logging level is enabled app-wide
	if cfg.LoggingLevel == config.LogLevelDebug {
		vsphere.EnableLogging()
	}

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	// Record thresholds for use as Nagios "Long Service Output" content. This
	// content is shown in the detailed web UI and in notifications generated
	// by Nagios.
	nagiosExitState.CriticalThreshold = fmt.Sprintf(
		"non-excluded VM with: %s\t"+strings.Join(
			[]string{
				"backup date exceeding specified CRITICAL threshold",
			},
			nagios.CheckOutputEOL+"\t",
		),
		nagios.CheckOutputEOL,
	)
	nagiosExitState.WarningThreshold = fmt.Sprintf(
		"non-excluded VM with: %s\t"+strings.Join(
			[]string{
				"backup date exceeding specified WARNING threshold, but not CRITICAL threshold",
				"backup date missing",
				"backup date does not match default/user-specified format",
			},
			nagios.CheckOutputEOL+"\t",
		),
		nagios.CheckOutputEOL,
	)

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	log := cfg.Log.With().
		Str("included_resource_pools", cfg.IncludedResourcePools.String()).
		Str("excluded_resource_pools", cfg.ExcludedResourcePools.String()).
		Str("ignored_vms", cfg.IgnoredVMs.String()).
		Int("backup_age_critical", cfg.VMBackupAgeCritical).
		Int("backup_age_warning", cfg.VMBackupAgeWarning).
		Logger()

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		nagiosExitState.AddError(loginErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	// At this point we're logged in, ready to retrieve a list of VMs. If
	// specified, we should limit VMs based on include/exclude lists. First,
	// we'll make sure that all specified resource pools actually exist in the
	// vSphere environment.

	log.Debug().Msg("Validating resource pools")
	validateErr := vsphere.ValidateRPs(ctx, c.Client, cfg.IncludedResourcePools, cfg.ExcludedResourcePools)
	if validateErr != nil {
		log.Error().Err(validateErr).Msg("error validating include/exclude lists")

		nagiosExitState.AddError(validateErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error validating include/exclude lists",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Msg("Retrieving eligible resource pools")
	resourcePools, getRPsErr := vsphere.GetEligibleRPs(
		ctx,
		c.Client,
		cfg.IncludedResourcePools,
		cfg.ExcludedResourcePools,
		true,
	)
	if getRPsErr != nil {
		log.Error().Err(getRPsErr).Msg(
			"error retrieving list of resource pools",
		)

		nagiosExitState.AddError(getRPsErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of resource pools from %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	rpNames := make([]string, 0, len(resourcePools))
	for _, rp := range resourcePools {
		rpNames = append(rpNames, rp.Name)
	}

	log.Debug().
		Str("resource_pools", strings.Join(rpNames, ", ")).
		Msg("evaluated resource pools")

	log.Debug().Msg("Retrieving vms from eligible resource pools")
	rpEntityVals := make([]mo.ManagedEntity, 0, len(resourcePools))
	for i := range resourcePools {
		rpEntityVals = append(rpEntityVals, resourcePools[i].ManagedEntity)
	}
	vms, getVMsErr := vsphere.GetVMsFromContainer(ctx, c.Client, true, rpEntityVals...)
	if getVMsErr != nil {
		log.Error().Err(getVMsErr).Msg(
			"error retrieving list of VMs from resource pools list",
		)

		nagiosExitState.AddError(getVMsErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving list of VMs from resource pools list",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().
		Str("vms_evaluated", strings.Join(vsphere.VMNames(vms), ", ")).
		Msg("Evaluated Virtual Machines")

	log.Debug().Msg("Drop any VMs we've been asked to exclude from checks")
	filteredVMs, numVMsExcludedByName := vsphere.ExcludeVMsByName(vms, cfg.IgnoredVMs)

	log.Debug().
		Str("vms_filtered_by_name", strings.Join(vsphere.VMNames(filteredVMs), ", ")).
		Int("vms_excluded_by_name", numVMsExcludedByName).
		Msg("VMs after name filtering")

	// NOTE: This plugin is hard-coded to evaluate powered off and powered
	// on VMs equally. I'm not sure whether ignoring powered off VMs by
	// default makes sense for this particular plugin.
	//
	// Please share your feedback here if you feel differently:
	// https://github.com/atc0005/check-vmware/discussions/176
	//
	// Please expand on some use cases for ignoring powered off VMs by default.
	//
	// 	log.Debug().Msg("Filter VMs to specified power state")
	// 	filteredVMs, numVMsExcludedByPowerState := vsphere.FilterVMsByPowerState(filteredVMs, cfg.PoweredOff)
	//
	// 	log.Debug().
	// 		Str("vms_filtered_by_power_state", strings.Join(vsphere.VMNames(filteredVMs), ", ")).
	// 		Int("vms_excluded_by_power_state", numVMsExcludedByPowerState).
	// 		Msg("VMs after power state filtering")

	// Here we diverge from most other plugins in this project

	vmsWithBackup, vmsLookupErr := vsphere.GetVMsWithBackup(
		filteredVMs,
		cfg.VMBackupDateTimezone,
		cfg.VMBackupDateCustomAttribute,
		cfg.VMBackupMetadataCustomAttribute,
		cfg.VMBackupDateFormat,
		cfg.VMBackupAgeCritical,
		cfg.VMBackupAgeWarning,
	)
	if vmsLookupErr != nil {

		log.Error().Err(vmsLookupErr).
			Msg("error retrieving virtual machines with requested backup custom attributes")

		nagiosExitState.AddError(vmsLookupErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving virtual machines with requested backup custom attributes",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	}

	log.Debug().Msg("Compiling Performance Data details")

	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "vms",
			Value: fmt.Sprintf("%d", len(vms)),
		},
		{
			Label: "vms_excluded_by_name",
			Value: fmt.Sprintf("%d", numVMsExcludedByName),
		},
		{
			Label: "vms_evaluated",
			Value: fmt.Sprintf("%d", len(filteredVMs)),
		},
		{
			Label: "vms_with_backup_dates",
			Value: fmt.Sprintf("%d", vmsWithBackup.NumBackups()),
		},
		{
			Label: "vms_without_backup_dates",
			Value: fmt.Sprintf("%d", vmsWithBackup.NumWithoutBackups()),
		},
		{
			Label: "resource_pools_excluded",
			Value: fmt.Sprintf("%d", len(cfg.ExcludedResourcePools)),
		},
		{
			Label: "resource_pools_included",
			Value: fmt.Sprintf("%d", len(cfg.IncludedResourcePools)),
		},
		{
			Label: "resource_pools_evaluated",
			Value: fmt.Sprintf("%d", len(resourcePools)),
		},
	}

	// Update logger with new performance data related fields
	log = log.With().
		Int("vms_total", len(vms)).
		Int("vms_filtered", len(filteredVMs)).
		Int("vms_excluded_by_name", numVMsExcludedByName).
		Int("vms_with_backup_dates", vmsWithBackup.NumBackups()).
		Int("vms_without_backup_dates", vmsWithBackup.NumWithoutBackups()).
		Int("resource_pools_evaluated", len(resourcePools)).
		Logger()

	switch {
	case vmsWithBackup.IsCriticalState() || vmsWithBackup.IsWarningState():

		nagiosExitState.AddError(func() error {
			switch {

			// Something prevented a regularly scheduled backup from
			// running/completing.
			//
			// We consider this error to be of a higher priority, so we check
			// for it first before we look for missing backups.
			case vmsWithBackup.HasOldBackup():
				return vsphere.ErrVirtualMachineBackupDateOld

			// One or more of the non-excluded VMs does not have a backup
			// associated with it (for whatever reason).
			case !vmsWithBackup.AllHasBackup():
				return vsphere.ErrVirtualMachineMissingBackupDate

			default:
				return errors.New("unknown error state; please report this")

			}
		}())

		stateLabel := nagios.StateCRITICALLabel
		stateExitCode := nagios.StateCRITICALExitCode
		if vmsWithBackup.IsWarningState() {
			stateLabel = nagios.StateWARNINGLabel
			stateExitCode = nagios.StateWARNINGExitCode
		}

		nagiosExitState.ServiceOutput = vsphere.VMBackupViaCAOneLineCheckSummary(
			stateLabel,
			vms,
			filteredVMs,
			vmsWithBackup,
			resourcePools,
		)

		nagiosExitState.LongServiceOutput = vsphere.VMBackupViaCAReport(
			c.Client,
			vms,
			filteredVMs,
			vmsWithBackup,
			cfg.IgnoredVMs,
			cfg.IncludedResourcePools,
			cfg.ExcludedResourcePools,
			resourcePools,
		)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		nagiosExitState.ExitStatusCode = stateExitCode

	default:

		// success if we made it here

		log.Debug().Msg("No non-excluded VMs with old or missing backups detected")

		nagiosExitState.ServiceOutput = vsphere.VMBackupViaCAOneLineCheckSummary(
			nagios.StateOKLabel,
			vms,
			filteredVMs,
			vmsWithBackup,
			resourcePools,
		)

		nagiosExitState.LongServiceOutput = vsphere.VMBackupViaCAReport(
			c.Client,
			vms,
			filteredVMs,
			vmsWithBackup,
			cfg.IgnoredVMs,
			cfg.IncludedResourcePools,
			cfg.ExcludedResourcePools,
			resourcePools,
		)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		nagiosExitState.ExitStatusCode = nagios.StateOKExitCode

	}
}
