// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/atc0005/go-nagios"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	"github.com/rs/zerolog"
	zlog "github.com/rs/zerolog/log"
)

func main() {

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Collect last minute details just before ending plugin execution.
	defer func(plugin *nagios.Plugin) {
		// Annotate errors (if applicable) with additional context to aid in
		// troubleshooting.
		plugin.Errors = vsphere.AnnotateError(plugin.Errors...)
	}(plugin)

	// Disable library debug logging output by default
	// vsphere.EnableLogging()
	vsphere.DisableLogging()

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{DatastoresPerformance: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Enable library-level logging if debug logging level is enabled app-wide
	if cfg.LoggingLevel == config.LogLevelDebug {
		vsphere.EnableLogging()
	}

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	// Record thresholds for use as Nagios "Long Service Output" content. This
	// content is shown in the detailed web UI and in notifications generated
	// by Nagios.
	plugin.CriticalThreshold = cfg.DatastorePerfPercentileSet().CriticalThresholdValues()
	plugin.WarningThreshold = cfg.DatastorePerfPercentileSet().WarningThresholdValues()

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	dcName := cfg.DatacenterName
	if dcName == "" {
		dcName = "not provided"
	}

	log := cfg.Log.With().
		Str("datastore_name", cfg.DatastoreName).
		Str("datacenter_name", dcName).
		Logger()

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		plugin.AddError(loginErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	// At this point we're logged in, ready to retrieve the requested
	// datastore.

	log.Debug().Msg("Retrieving datastore by name")
	datastore, dsFetchErr := vsphere.GetDatastoreByName(
		ctx,
		c.Client,
		cfg.DatastoreName,
		cfg.DatacenterName,
		true,
	)
	if dsFetchErr != nil {
		log.Error().Err(dsFetchErr).Msg(
			"error retrieving requested datastore",
		)

		plugin.AddError(dsFetchErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving datastore %q",
			nagios.StateCRITICALLabel,
			cfg.DatastoreName,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Msg("Successfully retrieved datastore by name")

	log.Debug().Msg("Asserting that datastore is accessible; metadata from an inaccessible datastore is unreliable")
	dsInaccessibleReasons, dsAccessibilityErr := vsphere.ValidateDatastoreAccessibility(datastore)
	if dsAccessibilityErr != nil {
		log.Error().Err(dsAccessibilityErr).
			Str("reasons", strings.Join(dsInaccessibleReasons, ", ")).
			Msg("datastore is inaccessible")

		plugin.AddError(dsAccessibilityErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Datastore %q is inaccessible due to: [%s]",
			nagios.StateCRITICALLabel,
			cfg.DatastoreName,
			strings.Join(dsInaccessibleReasons, ", "),
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Msg("Successfully asserted that datastore is accessible")

	log.Debug().Msg("Process datastore performance thresholds specified by user")

	// Attach a metrics dictionary to the existing logger for each percentile
	// in the thresholds index.
	perfThresholds := cfg.DatastorePerfPercentileSet()
	for percentile, thresholds := range perfThresholds {
		pStr := strconv.Itoa(percentile)
		log = log.With().Dict(pStr, zerolog.Dict().
			Float64("read_latency_warning", thresholds.ReadLatencyWarning).
			Float64("read_latency_critical", thresholds.ReadLatencyCritical).
			Float64("write_latency_warning", thresholds.WriteLatencyWarning).
			Float64("write_latency_critical", thresholds.WriteLatencyCritical).
			Float64("vm_latency_warning", thresholds.VMLatencyWarning).
			Float64("vm_latency_critical", thresholds.VMLatencyCritical),
		).Logger()
	}

	// Convert config package specific thresholds collection to vsphere
	// package compatible type.
	//
	// TODO: This works, but still feels wrong. What is a better approach?
	perfThresholdsIndex := make(vsphere.DatastorePerformanceThresholdsIndex)
	for k, v := range perfThresholds {
		perfThresholdsIndex[k] = vsphere.DatastorePerformanceThresholds(v)
	}

	// TODO: Review the error handling here for potential refactoring work.
	dsPerfSummarySet, dsPerfErr := vsphere.NewDatastorePerformanceSet(ctx, c.Client, datastore, perfThresholdsIndex)
	if dsPerfErr != nil {

		defErrorHandler := func(plugin *nagios.Plugin, serviceState nagios.ServiceState, err error) {
			log.Error().Err(err).Msg(
				"unable to retrieve performance summary for datastore",
			)

			plugin.AddError(err)
			plugin.ServiceOutput = fmt.Sprintf(
				"%s: Unable to retrieve performance summary for datastore %q: %s",
				serviceState.Label,
				cfg.DatastoreName,
				err.Error(),
			)
			plugin.ExitStatusCode = serviceState.ExitCode
		}

		switch {

		// Force early OK state if metrics are missing and we've been asked to
		// ignore that condition. We'll skip generating LongServiceOutput
		// content / report details for this scenario.
		case cfg.IgnoreMissingDatastorePerfMetrics &&
			errors.Is(dsPerfErr, vsphere.ErrDatastorePerformanceMetricsMissing):

			log.Debug().
				Err(dsPerfErr).
				Msg("Ignoring missing Datastore performance metrics as requested")

			plugin.ServiceOutput = fmt.Sprintf(
				"%s: Datastore Performance metrics unavailable for datastore %q; ignoring as requested",
				nagios.StateOKLabel,
				cfg.DatastoreName,
			)
			plugin.ExitStatusCode = nagios.StateOKExitCode

			return

		// We are unable to retrieve the parent property which contains
		// storage I/O management settings. This is considered an
		// unrecoverable error.
		case errors.Is(dsPerfErr, vsphere.ErrDatastoreIormConfigurationPropertyUnavailable):

			defErrorHandler(plugin, nagios.ServiceState{
				Label:    nagios.StateCRITICALLabel,
				ExitCode: nagios.StateCRITICALExitCode,
			},
				dsPerfErr,
			)

			return

		// We are able to retrieve the parent property which contains storage
		// I/O management settings, but are not able to retrieve the specific
		// property which identifies whether statistics collection is enabled.
		// This is considered an unrecoverable error.
		case errors.Is(dsPerfErr, vsphere.ErrDatastoreStatsCollectionPropertyUnavailable):

			defErrorHandler(plugin, nagios.ServiceState{
				Label:    nagios.StateCRITICALLabel,
				ExitCode: nagios.StateCRITICALExitCode,
			},
				dsPerfErr,
			)

			return

		// Performance statistics gathering is definitively disabled. We treat
		// this as an UNKNOWN state because while we can make a best guess,
		// it's not definitive. We treat this as unrecoverable state which is
		// outside of this plugin's control, but direct the sysadmin to reach
		// out to their vmware admins for assistance with enabling statistics
		// collection for the Datastore.
		case errors.Is(dsPerfErr, vsphere.ErrDatastoreIormConfigurationStatisticsCollectionDisabled):

			defErrorHandler(plugin, nagios.ServiceState{
				Label:    nagios.StateUNKNOWNLabel,
				ExitCode: nagios.StateUNKNOWNExitCode,
			},
				dsPerfErr,
			)

			return

		// If we're not dealing with a very specific known & acceptable
		// scenario, treat returned errors as CRITICAL and fail early.
		default:

			defErrorHandler(plugin, nagios.ServiceState{
				Label:    nagios.StateCRITICALLabel,
				ExitCode: nagios.StateCRITICALExitCode,
			},
				dsPerfErr,
			)

			return

		}

	}

	log.Debug().
		Int("intervals", len(dsPerfSummarySet.Intervals)).
		Msg("performance summaries collected")

	// Get active result set. Unless *no* datastore performance summary
	// results are retrieved (scenario handled earlier), there will be at
	// least one result to evaluate.
	log.Debug().Msg("Active interval metrics")

	activePerfSummaryIdx, activePerfSummaryErr := dsPerfSummarySet.ActivePerfSummaryIndex()
	if activePerfSummaryErr != nil {
		log.Error().Err(activePerfSummaryErr).Msg(
			"error retrieving datastore performance summary details for active interval",
		)

		plugin.AddError(activePerfSummaryErr)
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving datastore %q",
			nagios.StateCRITICALLabel,
			cfg.DatastoreName,
		)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Emit debugging details for potential troubleshooting.
	for percentile, summary := range activePerfSummaryIdx.Entries {
		log.Debug().
			Float64("datastore_read_latency", summary.ReadLatency).
			Float64("datastore_write_latency", summary.WriteLatency).
			Float64("datastore_vm_latency", summary.VMLatency).
			Float64("datastore_read_iops", summary.ReadIops).
			Float64("datastore_write_iops", summary.WriteIops).
			Int32("interval", summary.Interval).
			Int("percentile", percentile).
			Msg("Stats for percentile")
	}

	log.Debug().Msg("Compiling Performance Data details")

	// Baseline performance data metrics.
	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "vms",
			Value: fmt.Sprintf("%d", len(dsPerfSummarySet.VMs)),
		},
		{
			Label: "vms_powered_off",
			Value: fmt.Sprintf("%d", dsPerfSummarySet.VMs.NumVMsPoweredOff()),
		},
		{
			Label: "vms_powered_on",
			Value: fmt.Sprintf("%d", dsPerfSummarySet.VMs.NumVMsPoweredOn()),
		},
	}

	// Collect performance data metrics for each percentile in the active
	// interval.
	percentiles := activePerfSummaryIdx.Percentiles()
	for _, percentile := range percentiles {

		summary := activePerfSummaryIdx.Entries[percentile]

		switch {
		case !summary.IsZero():
			log.Debug().
				Int("percentile", percentile).
				Msg("Summary metrics for percentile are available, including in perf data")

			metricsPerfData := []nagios.PerformanceData{
				{
					Label: fmt.Sprintf("p%d_read_latency", percentile),
					Value: fmt.Sprintf("%f", summary.ReadLatency),
				},
				{
					Label: fmt.Sprintf("p%d_write_latency", percentile),
					Value: fmt.Sprintf("%f", summary.WriteLatency),
				},
				{
					Label: fmt.Sprintf("p%d_vm_latency", percentile),
					Value: fmt.Sprintf("%f", summary.VMLatency),
				},
				{
					Label: fmt.Sprintf("p%d_read_iops", percentile),
					Value: fmt.Sprintf("%d", int64(summary.ReadIops)),
				},
				{
					Label: fmt.Sprintf("p%d_write_iops", percentile),
					Value: fmt.Sprintf("%d", int64(summary.WriteIops)),
				},
			}

			pd = append(metricsPerfData, pd...)

		// Skip inclusion of all zero metrics in an effort to prevent skewing
		// performance data collected prior to this point. This scenario is
		// known to occur just after the active interval "rolls over" and a
		// new active interval begins.
		default:
			log.Debug().
				Int("percentile", percentile).
				Msg("Summary metrics for percentile are empty, skipping inclusion in perf data")
		}

	}

	// Update logger with baseline performance data related fields. Skipping
	// inclusion of all metrics due to large number of values.
	log = log.With().
		Int("vms", len(dsPerfSummarySet.VMs)).
		Int("vms_powered_off", dsPerfSummarySet.VMs.NumVMsPoweredOff()).
		Int("vms_powered_on", dsPerfSummarySet.VMs.NumVMsPoweredOn()).
		Logger()

	log.Debug().Msg("Evaluating datastore performance state")
	switch {

	case dsPerfSummarySet.IsUnknownState():

		log.Error().Msg("Datastore performance UNKNOWN")

		plugin.AddError(dsPerfSummarySet.UnknownState())

		plugin.ServiceOutput = vsphere.DatastorePerformanceOneLineCheckSummary(
			nagios.StateUNKNOWNLabel,
			dsPerfSummarySet,
		)

		plugin.LongServiceOutput = vsphere.DatastorePerformanceReport(
			c.Client,
			dsPerfSummarySet,
			cfg.HideHistoricalDatastorePerfMetricSets,
		)

		if err := plugin.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return

	case activePerfSummaryIdx.IsCriticalState():

		log.Error().Msg("Datastore performance CRITICAL")

		plugin.AddError(vsphere.ErrDatastoreLatencyThresholdCrossed)

		plugin.ServiceOutput = vsphere.DatastorePerformanceOneLineCheckSummary(
			nagios.StateCRITICALLabel,
			dsPerfSummarySet,
		)

		plugin.LongServiceOutput = vsphere.DatastorePerformanceReport(
			c.Client,
			dsPerfSummarySet,
			cfg.HideHistoricalDatastorePerfMetricSets,
		)

		if err := plugin.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		plugin.ExitStatusCode = nagios.StateCRITICALExitCode

		return

	case activePerfSummaryIdx.IsWarningState():

		log.Error().Msg("Datastore performance WARNING")

		plugin.AddError(vsphere.ErrDatastoreLatencyThresholdCrossed)

		plugin.ServiceOutput = vsphere.DatastorePerformanceOneLineCheckSummary(
			nagios.StateWARNINGLabel,
			dsPerfSummarySet,
		)

		plugin.LongServiceOutput = vsphere.DatastorePerformanceReport(
			c.Client,
			dsPerfSummarySet,
			cfg.HideHistoricalDatastorePerfMetricSets,
		)

		if err := plugin.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		plugin.ExitStatusCode = nagios.StateWARNINGExitCode

		return

	default:

		log.Debug().Msg("Datastore performance within specified thresholds")

		plugin.ServiceOutput = vsphere.DatastorePerformanceOneLineCheckSummary(
			nagios.StateOKLabel,
			dsPerfSummarySet,
		)

		plugin.LongServiceOutput = vsphere.DatastorePerformanceReport(
			c.Client,
			dsPerfSummarySet,
			cfg.HideHistoricalDatastorePerfMetricSets,
		)

		if err := plugin.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		plugin.ExitStatusCode = nagios.StateOKExitCode

		return

	}

}
