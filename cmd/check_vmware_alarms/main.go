// Copyright 2021 Adam Chalkley
//
// https://github.com/atc0005/check-vmware
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/atc0005/go-nagios"
	"github.com/vmware/govmomi/vim25/mo"

	"github.com/atc0005/check-vmware/internal/config"
	"github.com/atc0005/check-vmware/internal/vsphere"

	zlog "github.com/rs/zerolog/log"
)

func main() {

	// Start the timer. We'll use this to emit the plugin runtime as a
	// performance data metric.
	pluginStart := time.Now()

	// Set initial "state" as valid, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Collect last minute details just before ending plugin execution.
	defer func(exitState *nagios.ExitState, start time.Time) {

		// Record plugin runtime, emit this metric regardless of exit
		// point/cause.
		runtimeMetric := nagios.PerformanceData{
			Label: "time",
			Value: fmt.Sprintf("%dms", time.Since(start).Milliseconds()),
		}
		if err := exitState.AddPerfData(false, runtimeMetric); err != nil {
			zlog.Error().
				Err(err).
				Msg("failed to add time (runtime) performance data metric")
		}

		// Annotate errors (if applicable) with additional context to aid in
		// troubleshooting.
		nagiosExitState.Errors = vsphere.AnnotateError(nagiosExitState.Errors...)
	}(&nagiosExitState, pluginStart)

	// Disable library debug logging output by default
	// vsphere.EnableLogging()
	vsphere.DisableLogging()

	// Setup configuration by parsing user-provided flags. Note plugin type so
	// that only applicable CLI flags are exposed and any plugin-specific
	// settings are applied.
	cfg, cfgErr := config.New(config.PluginType{Alarms: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.AddError(cfgErr)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	// Enable library-level logging if debug logging level is enabled app-wide
	if cfg.LoggingLevel == config.LogLevelDebug {
		vsphere.EnableLogging()
	}

	// Set context deadline equal to user-specified timeout value for plugin
	// runtime/execution.
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout())
	defer cancel()

	// Record thresholds for use as Nagios "Long Service Output" content. This
	// content is shown in the detailed web UI and in notifications generated
	// by Nagios.
	// https://vdc-download.vmware.com/vmwb-repository/dcr-public/a5f4000f-1ea8-48a9-9221-586adff3c557/7ff50256-2cf2-45ea-aacd-87d231ab1ac7/vim.ManagedEntity.html#overallStatus
	nagiosExitState.CriticalThreshold = "One or more non-excluded alarms with a red status"
	nagiosExitState.WarningThreshold = "One or more non-excluded alarms with a yellow status"

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	log := cfg.Log.With().
		Str("datacenter_names", strings.Join(cfg.DatacenterNames, ", ")).
		Bool("eval_acknowledged_alarms", cfg.EvaluateAcknowledgedAlarms).
		Logger()

	log.Debug().Msg("Logging into vSphere environment")
	c, loginErr := vsphere.Login(
		ctx, cfg.Server, cfg.Port, cfg.TrustCert,
		cfg.Username, cfg.Domain, cfg.Password,
		cfg.UserAgent(),
	)
	if loginErr != nil {
		log.Error().Err(loginErr).Msgf("error logging into %s", cfg.Server)

		nagiosExitState.AddError(loginErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error logging into %q",
			nagios.StateCRITICALLabel,
			cfg.Server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}
	log.Debug().Msg("Successfully logged into vSphere environment")

	defer func() {
		if err := c.Logout(ctx); err != nil {
			log.Error().
				Err(err).
				Msg("failed to logout")
		}
	}()

	// At this point we're logged in, ready to process alarms.

	log.Debug().
		Int("datacenters_specified", len(cfg.DatacenterNames)).
		Msg("Validating datacenter names")
	validateDCsErr := vsphere.ValidateDCs(ctx, c.Client, cfg.DatacenterNames)
	if validateDCsErr != nil {
		log.Error().Err(validateDCsErr).Msg("error validating datacenter names")

		nagiosExitState.AddError(validateDCsErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error validating requested datacenter names",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Msg("Retrieving Datacenters")
	dcs, dcsFetchErr := vsphere.GetDatacenters(ctx, c.Client, cfg.DatacenterNames, true)
	if dcsFetchErr != nil {
		log.Error().Err(dcsFetchErr).Msg("error retrieving datacenters")

		nagiosExitState.AddError(dcsFetchErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving datacenters",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	dcsEvalNames := func(dcs []mo.Datacenter) []string {
		names := make([]string, len(dcs))
		for i := range dcs {
			names[i] = dcs[i].Name
		}
		return names
	}(dcs)

	log.Debug().
		Int("datacenters_found", len(dcs)).
		Str("datacenters", strings.Join(dcsEvalNames, ", ")).
		Msg("Datacenters found")

	if len(cfg.ExcludedAlarmEntityResourcePools) > 0 || len(cfg.IncludedAlarmEntityResourcePools) > 0 {
		// If include/exclude lists for Resource Pools (associated with Triggered
		// Alarm entities) were provided, validate those.
		log.Debug().Msg("Validating provided resource pool names")
		validateRPsErr := vsphere.ValidateRPs(
			ctx,
			c.Client,
			cfg.IncludedAlarmEntityResourcePools,
			cfg.ExcludedAlarmEntityResourcePools,
		)
		if validateRPsErr != nil {
			log.Error().Err(validateRPsErr).Msg("error validating include/exclude lists")

			nagiosExitState.AddError(validateRPsErr)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error validating include/exclude lists",
				nagios.StateCRITICALLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

			return
		}
	}

	triggeredAlarms, fetchAlarmsErr := vsphere.GetTriggeredAlarms(
		ctx,
		c,
		dcs,
		true,
	)

	if fetchAlarmsErr != nil {
		log.Error().Err(fetchAlarmsErr).Msg("error retrieving alarms")

		nagiosExitState.AddError(fetchAlarmsErr)
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error retrieving alarms",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	log.Debug().Int("total_triggered_alarms", len(triggeredAlarms)).Msg("")

	// Collect all filtering options together for easy reference.
	triggeredAlarmFilters := vsphere.TriggeredAlarmFilters{
		IncludedAlarmEntityTypes:         cfg.IncludedAlarmEntityTypes,
		ExcludedAlarmEntityTypes:         cfg.ExcludedAlarmEntityTypes,
		IncludedAlarmEntityNames:         cfg.IncludedAlarmEntityNames,
		ExcludedAlarmEntityNames:         cfg.ExcludedAlarmEntityNames,
		IncludedAlarmEntityResourcePools: cfg.IncludedAlarmEntityResourcePools,
		ExcludedAlarmEntityResourcePools: cfg.ExcludedAlarmEntityResourcePools,
		IncludedAlarmNames:               cfg.IncludedAlarmNames,
		ExcludedAlarmNames:               cfg.ExcludedAlarmNames,
		IncludedAlarmDescriptions:        cfg.IncludedAlarmDescriptions,
		ExcludedAlarmDescriptions:        cfg.ExcludedAlarmDescriptions,
		IncludedAlarmStatuses:            cfg.IncludedAlarmStatuses,
		ExcludedAlarmStatuses:            cfg.ExcludedAlarmStatuses,
		EvaluateAcknowledgedAlarms:       cfg.EvaluateAcknowledgedAlarms,
	}

	var numTriggeredAlarmsToReport int
	if len(triggeredAlarms) > 0 {
		// Filter Triggered Alarms using requested settings, marking alarms as
		// explicitly included or excluded, but retaining them in the
		// collection for further potential evaluation.
		triggeredAlarms.Filter(triggeredAlarmFilters)

		numTriggeredAlarmsToReport = len(triggeredAlarms) - triggeredAlarms.NumExcluded()
		if numTriggeredAlarmsToReport < 0 {
			numTriggeredAlarmsToReport = 0
		}

		log.Debug().
			Int("remaining_triggered_alarms", numTriggeredAlarmsToReport).
			Msg("triggered alarms remaining after filtering")
	}

	log.Debug().Msg("Compiling Performance Data details")

	pd := []nagios.PerformanceData{
		// The `time` (runtime) metric is appended at plugin exit, so do not
		// duplicate it here.
		{
			Label: "datacenters",
			Value: fmt.Sprintf("%d", len(dcs)),
		},
		{
			Label: "triggered_alarms",
			Value: fmt.Sprintf("%d", len(triggeredAlarms)),
		},
		{
			Label: "triggered_alarms_included",
			Value: fmt.Sprintf("%d", numTriggeredAlarmsToReport),
		},
		{
			Label: "triggered_alarms_excluded",
			Value: fmt.Sprintf("%d", triggeredAlarms.NumExcluded()),
		},
		{
			Label: "triggered_alarms_critical",
			Value: fmt.Sprintf("%d", triggeredAlarms.NumCriticalState(false)),
		},
		{
			Label: "triggered_alarms_warning",
			Value: fmt.Sprintf("%d", triggeredAlarms.NumWarningState(false)),
		},
		{
			Label: "triggered_alarms_unknown",
			Value: fmt.Sprintf("%d", triggeredAlarms.NumUnknownState(false)),
		},
		{
			Label: "triggered_alarms_ok",
			Value: fmt.Sprintf("%d", triggeredAlarms.NumOKState(false)),
		},
	}

	// Update logger with new performance data related fields
	log = log.With().
		Int("datacenters", len(dcs)).
		Int("triggered_alarms", len(triggeredAlarms)).
		Int("triggered_alarms_included", numTriggeredAlarmsToReport).
		Int("triggered_alarms_excluded", triggeredAlarms.NumExcluded()).
		Int("triggered_alarms_critical", triggeredAlarms.NumCriticalState(false)).
		Int("triggered_alarms_warning", triggeredAlarms.NumWarningState(false)).
		Int("triggered_alarms_unknown", triggeredAlarms.NumUnknownState(false)).
		Int("triggered_alarms_ok", triggeredAlarms.NumOKState(false)).
		Logger()

	switch {

	case len(triggeredAlarms) > 0:

		if !triggeredAlarms.IsOKState(false) {
			log.Error().
				Int("total_triggered_alarms", len(triggeredAlarms)).
				Int("remaining_alarms", numTriggeredAlarmsToReport).
				Int("excluded_triggered_alarms", triggeredAlarms.NumExcluded()).
				Msg("Non-excluded alarms detected")
		}

		// Set state label and exit code based on most severe
		// ManagedEntityStatus found in the TriggeredAlarms collection. Record
		// error if any TriggeredAlarms remain after filtering.
		var stateLabel string
		switch {
		case triggeredAlarms.HasCriticalState(false):
			stateLabel = nagios.StateCRITICALLabel
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			nagiosExitState.AddError(vsphere.ErrAlarmNotExcludedFromEvaluation)

		case triggeredAlarms.HasWarningState(false):
			stateLabel = nagios.StateWARNINGLabel
			nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
			nagiosExitState.AddError(vsphere.ErrAlarmNotExcludedFromEvaluation)

		case triggeredAlarms.HasUnknownState(false):
			stateLabel = nagios.StateUNKNOWNLabel
			nagiosExitState.ExitStatusCode = nagios.StateUNKNOWNExitCode
			nagiosExitState.AddError(vsphere.ErrAlarmNotExcludedFromEvaluation)

		// though we started off with triggered alarms, it's possible that we
		// filtered all of them out by this point
		default:

			// success path

			stateLabel = nagios.StateOKLabel
			nagiosExitState.ExitStatusCode = nagios.StateOKExitCode

		}

		nagiosExitState.ServiceOutput = vsphere.AlarmsOneLineCheckSummary(
			stateLabel,
			triggeredAlarms,
			dcsEvalNames,
		)

		nagiosExitState.LongServiceOutput = vsphere.AlarmsReport(
			c.Client,
			triggeredAlarms,
			triggeredAlarmFilters,
			cfg.DatacenterNames,
			dcsEvalNames,
		)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	default:

		// success path

		log.Debug().Msg("No non-excluded alarms detected")

		nagiosExitState.ExitStatusCode = nagios.StateOKExitCode

		nagiosExitState.ServiceOutput = vsphere.AlarmsOneLineCheckSummary(
			nagios.StateOKLabel,
			triggeredAlarms,
			dcsEvalNames,
		)

		nagiosExitState.LongServiceOutput = vsphere.AlarmsReport(
			c.Client,
			triggeredAlarms,
			triggeredAlarmFilters,
			cfg.DatacenterNames,
			dcsEvalNames,
		)

		if err := nagiosExitState.AddPerfData(false, pd...); err != nil {
			log.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	}

}
